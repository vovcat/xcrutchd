// sed -e '/[b]egin binary/,/[e]nd binary/ d' -e '/[C]MD:/ {p;s/\/\* [C]MD: \(.*\) \*\//\1/e}' -i aplaypop.c
// gcc -W -Wall -DMAIN -o aplaypop aplaypop.c -lasound && ./aplaypop

#include <stdio.h>      // printf()
#include <unistd.h>     // write(), sleep()
#include <fcntl.h>      // O_WRONLY
#include <sys/ioctl.h>  // ioctl()

#include <alsa/asoundlib.h>
#include "aplaypop.h"

#define RATE 48000   /* the sampling rate */
#define SIZE 16      /* sample size: 8 or 16 bits */
#define CHANNELS 1   /* 1 = mono 2 = stereo */

/* this buffer holds the digitized audio */
/* CMD: sox ~/.xkb/MenuPop.wav -r 48k -e signed -b 16 -c 1 -t raw - vol 1 |bin2hex.pl - 1 */
/* begin binary data: */
char bin_data[] = /* 770 */
{0xE4,0xFF,0xBA,0xFF,0xFF,0xFF,0x5F,0x00,0x4A,0x00,0x32,0x00,0x2D,0x00,0x33
,0xFE,0xC1,0xF7,0xE8,0xEE,0x7C,0xEC,0x9B,0xF9,0xFD,0x14,0x05,0x30,0xEF,0x38
,0x0E,0x29,0xF1,0x08,0xA1,0xE7,0xAD,0xCF,0xC9,0xC4,0x18,0xC8,0x0F,0xDA,0xEA
,0xF6,0x49,0x14,0xE8,0x25,0xB6,0x25,0x2D,0x17,0x58,0x03,0x16,0xF3,0x60,0xEC
,0xD2,0xF1,0xB2,0x01,0x4E,0x15,0xA0,0x23,0x80,0x26,0xAC,0x1D,0x13,0x0D,0x3A
,0xF9,0x0E,0xE6,0x0B,0xD8,0x1B,0xD4,0xC0,0xDC,0x5C,0xEF,0xB9,0x04,0xA4,0x14
,0x85,0x19,0x2F,0x12,0x00,0x02,0xCC,0xEF,0x57,0xE3,0xF8,0xE1,0x59,0xEC,0xC3
,0xFE,0x5A,0x13,0x5C,0x24,0x67,0x2D,0x38,0x2C,0x32,0x21,0x40,0x0F,0xE2,0xFA
,0xE2,0xE8,0x70,0xDD,0x40,0xDB,0x8A,0xE2,0x5D,0xF0,0x78,0xFF,0x74,0x0A,0xFA
,0x0D,0xBA,0x09,0x10,0x00,0x0F,0xF5,0x1A,0xED,0x69,0xEB,0xD0,0xF0,0xC0,0xFB
,0x47,0x09,0x11,0x16,0x0D,0x1F,0xE3,0x21,0xC0,0x1D,0xC8,0x13,0x9B,0x06,0x55
,0xF9,0xF6,0xEE,0x29,0xEA,0x86,0xEC,0x23,0xF5,0x02,0x00,0xB0,0x07,0x22,0x08
,0xBE,0x00,0x4F,0xF4,0xE9,0xE7,0x5E,0xE1,0x1E,0xE5,0x71,0xF3,0x10,0x07,0x79
,0x17,0x2B,0x1E,0xA8,0x1A,0xC4,0x11,0x55,0x09,0x79,0x04,0x16,0x03,0x94,0x03
,0x4C,0x04,0xF3,0x03,0xEC,0x01,0xB1,0xFE,0x9A,0xFB,0x84,0xF9,0xC8,0xF7,0xE2
,0xF4,0x5A,0xF0,0xE9,0xEB,0x94,0xEA,0x86,0xEE,0x64,0xF7,0x54,0x02,0x56,0x0B
,0x47,0x0F,0x67,0x0D,0xE0,0x07,0xB4,0x02,0x97,0x01,0xC0,0x05,0x1D,0x0D,0x67
,0x13,0xA3,0x14,0x7D,0x0F,0xEE,0x05,0xC2,0xFB,0x12,0xF4,0xC0,0xEF,0xEE,0xED
,0xA9,0xED,0xD3,0xEE,0xB1,0xF1,0xFD,0xF5,0xA0,0xFA,0x65,0xFE,0x96,0x00,0x39
,0x01,0x0F,0x01,0x63,0x01,0x5C,0x03,0x0F,0x07,0x39,0x0B,0x4E,0x0E,0xD1,0x0F
,0x46,0x10,0xEC,0x0F,0xCC,0x0D,0xB5,0x08,0xF3,0x00,0xAA,0xF8,0x51,0xF2,0x17
,0xEF,0xC1,0xEE,0x97,0xF0,0xDB,0xF3,0x8A,0xF7,0x72,0xFA,0x05,0xFC,0xCF,0xFC
,0xBE,0xFD,0x13,0xFF,0x75,0x00,0x03,0x02,0xC3,0x04,0x6E,0x09,0x2E,0x0F,0xD2
,0x13,0x70,0x15,0x8C,0x13,0xC0,0x0E,0xD0,0x07,0x89,0xFF,0x31,0xF7,0x9D,0xF0
,0x69,0xED,0x3A,0xEE,0x74,0xF2,0x5B,0xF8,0x5E,0xFD,0x04,0xFF,0x78,0xFC,0x87
,0xF7,0xBF,0xF3,0x0A,0xF4,0xD0,0xF8,0x62,0x00,0x94,0x08,0xD2,0x0F,0xD1,0x14
,0x50,0x16,0xC6,0x13,0x3E,0x0E,0xF1,0x07,0xCB,0x02,0x47,0xFF,0xCC,0xFC,0xB5
,0xFA,0xC2,0xF8,0xD7,0xF6,0xD5,0xF4,0xF7,0xF2,0xF6,0xF1,0x7F,0xF2,0x87,0xF4
,0x53,0xF7,0x34,0xFA,0x06,0xFD,0xE0,0xFF,0xB0,0x02,0x44,0x05,0xBC,0x07,0x81
,0x0A,0xA9,0x0D,0x77,0x10,0x9C,0x11,0x1A,0x10,0xFF,0x0B,0x59,0x06,0xA5,0x00
,0x0E,0xFC,0xDC,0xF8,0x66,0xF6,0xD0,0xF3,0x02,0xF1,0x05,0xEF,0x44,0xEF,0x44
,0xF2,0x16,0xF7,0x00,0xFC,0xB0,0xFF,0xD2,0x01,0xD1,0x02,0x6E,0x03,0x78,0x04
,0x9B,0x06,0xF8,0x09,0xE2,0x0D,0x1D,0x11,0x92,0x12,0xAE,0x11,0x3D,0x0E,0x32
,0x08,0xFE,0xFF,0x22,0xF7,0x00,0xF0,0xB1,0xEC,0xC3,0xED,0xF7,0xF1,0x23,0xF7
,0x52,0xFB,0x57,0xFD,0x03,0xFD,0x10,0xFB,0xFB,0xF8,0x6E,0xF8,0x81,0xFA,0x4D
,0xFF,0x0B,0x06,0x6F,0x0D,0xCD,0x13,0x6B,0x17,0x02,0x17,0x6C,0x12,0xD0,0x0A
,0x21,0x02,0x5B,0xFA,0x05,0xF5,0xF3,0xF2,0xF6,0xF3,0xBB,0xF6,0x34,0xF9,0xB8
,0xF9,0x0B,0xF8,0x75,0xF5,0xD1,0xF3,0x67,0xF4,0x56,0xF7,0xC4,0xFB,0x8B,0x00
,0xD9,0x04,0x86,0x08,0xE4,0x0B,0x15,0x0F,0x98,0x11,0x70,0x12,0xDB,0x10,0xE6
,0x0C,0x6A,0x07,0x94,0x01,0x7A,0xFC,0xDB,0xF8,0xE7,0xF6,0x25,0xF6,0xB9,0xF5
,0xFB,0xF4,0x05,0xF4,0x7D,0xF3,0xFA,0xF3,0x95,0xF5,0x13,0xF8,0x3A,0xFB,0xE1
,0xFE,0xC4,0x02,0x76,0x06,0xA4,0x09,0x4C,0x0C,0x93,0x0E,0x57,0x10,0xFA,0x10
,0xA9,0x0F,0xF3,0x0B,0x4A,0x06,0xEB,0xFF,0x55,0xFA,0x8C,0xF6,0xB1,0xF4,0x28
,0xF4,0x2C,0xF4,0x4F,0xF4,0x9B,0xF4,0x4E,0xF5,0x8C,0xF6,0x43,0xF8,0x49,0xFA
,0x95,0xFC,0x43,0xFF,0x5F,0x02,0xCD,0x05,0x48,0x09,0x97,0x0C,0x6D,0x0F,0x36
,0x11,0x1D,0x11,0x97,0x0E,0xF0,0x09,0x32,0x04,0x78,0xFE,0x5C,0xF9,0x21,0xF5
,0x30,0xF2,0x00,0xF1,0xA2,0xF1,0x82,0xF3,0xE0,0xF5,0x43,0xF8,0x71,0xFA,0x21
,0xFC,0x2E,0xFD,0xF6,0xFD,0x45,0xFF,0xB2,0x01,0x2D,0x05,0x53,0x09,0xC5,0x0D
,0xD5,0x11,0x20,0x14,0x2B,0x13,0xA4,0x0E,0xD4,0x07,0x87,0x00,0xEE,0xF9,0xB5
,0xF4,0xA4,0xF1,0x5F,0xF1,0x50,0xF3,0xC6,0xF5,0x70,0xF7,0x7D,0xF8,0x9D,0xF9
,0x91,0xFA,0xA4,0xFA,0x8F,0xFA,0x8C,0xFC,0x8E,0x01,0x01,0x07,0xC9,0x08,0xA9
,0x05,0xCD,0x00,0x5C,0xFE};
/* end binary data. size = 770 bytes */

static char *device = "default"; //"plughw:0,0"; /* playback device */
static snd_pcm_t *pcm_handle;
static size_t frame_bytes;

static int aplaypop_open(void)
{
    int err;
    snd_pcm_t *handle;

    if (pcm_handle)
        return 0;

    snd_pcm_info_t *info;
    snd_pcm_info_alloca(&info);

    snd_output_t *log;
    err = snd_output_stdio_attach(&log, stderr, 0);
    assert(err == 0);

    err = snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK, 0);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_open(): %s\n", snd_strerror(err));
        //exit(EXIT_FAILURE);
        return err;
    }
    err = snd_pcm_nonblock(handle, 0);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_nonblock(): %s\n", snd_strerror(err));
        exit(EXIT_FAILURE);
    }
    err = snd_pcm_info(handle, info);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_info(): %s\n", snd_strerror(err));
        exit(EXIT_FAILURE);
    }

    // DOESN'T WORK!
    err = snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
        SND_PCM_ACCESS_RW_INTERLEAVED, CHANNELS, RATE, 1, 50000);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_set_params(): %s\n", snd_strerror(err));
        exit(EXIT_FAILURE);
    }

    // RIGHT WAY:
    snd_pcm_hw_params_t *hwparams;
    snd_pcm_sw_params_t *swparams;

    snd_pcm_format_t format = SND_PCM_FORMAT_S16_LE;
    unsigned int channels = CHANNELS;
    unsigned int rate = RATE;

    snd_pcm_hw_params_alloca(&hwparams);
    snd_pcm_sw_params_alloca(&swparams);

    err = snd_pcm_hw_params_any(handle, hwparams);
    if (err != 0) {
        fprintf(stderr, "Broken configuration for this PCM: %s\n", snd_strerror(err));
        exit(EXIT_FAILURE);
    }
    err = snd_pcm_hw_params_set_access(handle, hwparams, SND_PCM_ACCESS_RW_INTERLEAVED);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_hw_params_set_access(): %s\n", snd_strerror(err));
        exit(EXIT_FAILURE);
    }
    err = snd_pcm_hw_params_set_format(handle, hwparams, format);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_hw_params_set_format(): %s\n", snd_strerror(err));
        exit(EXIT_FAILURE);
    }
    err = snd_pcm_hw_params_set_channels(handle, hwparams, channels);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_hw_params_set_channels(): %s\n", snd_strerror(err));
        exit(EXIT_FAILURE);
    }
    err = snd_pcm_hw_params_set_rate_near(handle, hwparams, &rate, 0);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_hw_params_set_rate_near(): %s\n", snd_strerror(err));
        exit(EXIT_FAILURE);
    }
/*
    unsigned buffer_time = 0;
    snd_pcm_uframes_t buffer_frames = 0;

    if (buffer_time == 0 && buffer_frames == 0) {
        err = snd_pcm_hw_params_get_buffer_time_max(hwparams, &buffer_time, 0);
        assert(err == 0);
        if (buffer_time > 500000)
            buffer_time = 500000;
    }

    unsigned period_time = 0;
    snd_pcm_uframes_t period_frames = 0;

    if (period_time == 0 && period_frames == 0) {
        if (buffer_time > 0)
            period_time = buffer_time / 4;
        else
            period_frames = buffer_frames / 4;
    }

    if (period_time > 0)
        err = snd_pcm_hw_params_set_period_time_near(handle, hwparams, &period_time, 0);
    else
        err = snd_pcm_hw_params_set_period_size_near(handle, hwparams, &period_frames, 0);
    assert(err == 0);

    if (buffer_time > 0)
        err = snd_pcm_hw_params_set_buffer_time_near(handle, hwparams, &buffer_time, 0);
    else
        err = snd_pcm_hw_params_set_buffer_size_near(handle, hwparams, &buffer_frames);
    assert(err == 0);

    int monotonic = snd_pcm_hw_params_is_monotonic(hwparams);
    int can_pause = snd_pcm_hw_params_can_pause(hwparams);
*/
    err = snd_pcm_hw_params(handle, hwparams);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_hw_params(): %s\n", snd_strerror(err));
        snd_pcm_hw_params_dump(hwparams, log);
        exit(EXIT_FAILURE);
    }
    snd_pcm_uframes_t chunk_size = 0;
    snd_pcm_hw_params_get_period_size(hwparams, &chunk_size, 0);
    snd_pcm_uframes_t buffer_size;
    snd_pcm_hw_params_get_buffer_size(hwparams, &buffer_size);
    if (chunk_size == buffer_size) {
        fprintf(stderr, "Can't use period equal to buffer size (%lu == %lu)",
              chunk_size, buffer_size);
        exit(EXIT_FAILURE);
    }
    snd_pcm_sw_params_current(handle, swparams);

    err = snd_pcm_sw_params_set_avail_min(handle, swparams, chunk_size);
    assert(err == 0);

    /* round up to closest transfer boundary */
    int start_delay = 0;
    snd_pcm_uframes_t start_threshold;
    if (start_delay <= 0)
        start_threshold = buffer_size + (double) rate * start_delay / 1000000;
    else
        start_threshold = (double) rate * start_delay / 1000000;
    start_threshold = start_threshold < 1 ? 1 : start_threshold > buffer_size ? buffer_size : start_threshold;
    err = snd_pcm_sw_params_set_start_threshold(handle, swparams, start_threshold);
    assert(err == 0);

    int stop_delay = 0;
    snd_pcm_uframes_t stop_threshold;
    if (stop_delay <= 0)
        stop_threshold = buffer_size + (double) rate * stop_delay / 1000000;
    else
        stop_threshold = (double) rate * stop_delay / 1000000;
    err = snd_pcm_sw_params_set_stop_threshold(handle, swparams, stop_threshold);
    assert(err == 0);

    err = snd_pcm_sw_params(handle, swparams);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_sw_params(): %s\n", snd_strerror(err));
        snd_pcm_sw_params_dump(swparams, log);
        exit(EXIT_FAILURE);
    }
    // END OF THE RIGHT WAY

//  snd_pcm_dump(handle, log);

    size_t bits_per_sample = snd_pcm_format_physical_width(format);
    size_t bits_per_frame = bits_per_sample * channels;
    size_t chunk_bytes = chunk_size * bits_per_frame / 8;
    //audiobuf = realloc(audiobuf, chunk_bytes);

    fprintf(stderr, "%s: %s, Rate %d Hz, Channels=%u\n",
        snd_pcm_format_name(format), snd_pcm_format_description(format),
        rate, channels);
    fprintf(stderr, "  bits_per_sample=%u, bits_per_frame=%u, chunk_bytes=%u\n",
        bits_per_sample, bits_per_frame, chunk_bytes);

    frame_bytes = bits_per_frame / 8;
    pcm_handle = handle;
    return 0;
}

int aplaypop()
{
    int err = aplaypop_wake();
    if (err != 0)
        return -1;

    fprintf(stderr, "snd_pcm_state() = %s\n",
            snd_pcm_state_name(snd_pcm_state(pcm_handle)));

    err = snd_pcm_prepare(pcm_handle);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_start(): %s\n", snd_strerror(err));
        return -1;
    }

    int16_t *ptr = (int16_t *)bin_data;
    int len = sizeof(bin_data) / frame_bytes;

    while (len > 0) {
        // The unit of the buffersize depends on the function. Sometimes it is
        // given in bytes, sometimes the number of frames has to be specified.
        // One frame is the sample data vector for all channels.
        // For 16 Bit stereo data, one frame has a length of four bytes.
        snd_pcm_sframes_t frames = snd_pcm_writei(pcm_handle, ptr, len);
        fprintf(stderr, "  snd_pcm_writei(h, ptr, %d) = %ld\n", len, frames);
        if (frames == -EAGAIN) {
            frames = 0;
        } else if (frames < 0) { // -EPIPE, -ESTRPIPE
            frames = snd_pcm_recover(pcm_handle, frames, 1/*silent*/);
            if (frames < 0) {
                fprintf(stderr, "writei/recover failed: %s\n", snd_strerror(err));
                break;
            }
        } else if (frames < len) {
            fprintf(stderr, "Short write (expected %d, wrote %ld)\n", len, frames);
        } else {
            break; // All done
        }
        len -= frames * frame_bytes;
        ptr += frames * frame_bytes;
        snd_pcm_wait(pcm_handle, 10/*ms*/);
    }

    err = snd_pcm_drain(pcm_handle);
    if (err != 0) {
        fprintf(stderr, "snd_pcm_start(): %s\n", snd_strerror(err));
        return -1;
    }
    return 0;
}

int aplaypop_wake()
{
    if (pcm_handle == NULL && aplaypop_open() != 0)
        return -1;
    return 0;
}

int aplaypop_close()
{
    if (pcm_handle) {
        int err = snd_pcm_close(pcm_handle);
        if (err != 0) {
            fprintf(stderr, "snd_pcm_close(): %s\n", snd_strerror(err));
            pcm_handle = NULL;
            return -1;
        }
        pcm_handle = NULL;
    }
    return 0;
}

#ifdef MAIN
#include <unistd.h>
int main(int argc, char *argv[])
{
    if (argc > 1) {
        aplaypop_open();
        char c;
        read(0, &c, 1);
    } else {
        aplaypop();
    }
    aplaypop_close();
    return 0;
}
#endif
